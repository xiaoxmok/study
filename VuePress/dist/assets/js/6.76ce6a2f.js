(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{150:function(e,t,s){"use strict";s.r(t);var l=s(0),a=Object(l.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("div",{staticClass:"content"},[s("h1",{attrs:{id:"es6"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#es6","aria-hidden":"true"}},[e._v("#")]),e._v(" ES6")]),s("h2",{attrs:{id:"es6的了解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#es6的了解","aria-hidden":"true"}},[e._v("#")]),e._v(" ES6的了解")]),s("blockquote",[s("p",[e._v("新增模板字符串（为JavaScript提供了简单的字符串插值功能）、箭头函数（操作符左边为输入的参数，而右边则是进行的操作以及返回的值Inputs=>outputs。）、for-of（用来遍历数据—例如数组中的值。）arguments对象可被不定参数和默认参数完美代替。ES6将promise对象纳入规范，提供了原生的Promise对象。增加了let和const命令，用来声明变量。增加了块级作用域。let命令实际上就增加了块级作用域。ES6规定，var命令和function命令声明的全局变量，属于全局对象的属性；let命令、const命令、class命令声明的全局变量，不属于全局对象的属性。。还有就是引入module模块的概念")])]),s("h2",{attrs:{id:"说说你对promise的理解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#说说你对promise的理解","aria-hidden":"true"}},[e._v("#")]),e._v(" 说说你对Promise的理解")]),s("ul",[s("li",[s("p",[e._v("依照 Promise/A+ 的定义，Promise 有四种状态：")]),s("ul",[s("li",[s("p",[e._v("pending: 初始状态, 非 fulfilled 或 rejected.")])]),s("li",[s("p",[e._v("fulfilled: 成功的操作.")])]),s("li",[s("p",[e._v("rejected: 失败的操作.")])]),s("li",[s("p",[e._v("settled: Promise已被fulfilled或rejected，且不是pending")])])])]),s("li",[s("p",[e._v("另外， fulfilled 与 rejected 一起合称 settled")])]),s("li",[s("p",[e._v("Promise 对象用来进行延迟(deferred) 和异步(asynchronous ) 计算")])])]),s("h2",{attrs:{id:"promise-的构造函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#promise-的构造函数","aria-hidden":"true"}},[e._v("#")]),e._v(" Promise 的构造函数")]),s("ul",[s("li",[e._v("构造一个 Promise，最基本的用法如下：")])]),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("var promise = new Promise(function(resolve, reject) {\n\n        if (...) {  // succeed\n\n            resolve(result);\n\n        } else {   // fails\n\n            reject(Error(errMessage));\n\n        }\n    });\n")])])]),s("ul",[s("li",[e._v("Promise 实例拥有 then 方法（具有 then 方法的对象，通常被称为thenable）。它的使用方法如下：")])]),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("promise.then(onFulfilled, onRejected)\n")])])]),s("ul",[s("li",[e._v("接收两个函数作为参数，一个在 fulfilled 的时候被调用，一个在rejected的时候被调用，接收参数就是 future，onFulfilled 对应 resolve, onRejected 对应 reject")])]),s("p",[s("strong",[e._v("什么是 Promise ？")])]),s("ul",[s("li",[e._v("Promise 就是一个对象，用来表示并传递异步操作的最终结果")]),s("li",[e._v("Promise 最主要的交互方式：将回调函数传入 then 方法来获得最终结果或出错原因")]),s("li",[e._v("Promise 代码书写上的表现：以“链式调用”代替回调函数层层嵌套（回调地狱）")])]),s("p",[s("strong",[e._v("谈一谈你了解ECMAScript6的新特性？")])]),s("ul",[s("li",[e._v("块级作用区域              "),s("code",[e._v("let a = 1;")])]),s("li",[e._v("可定义常量                "),s("code",[e._v("const PI = 3.141592654;")])]),s("li",[e._v("变量解构赋值              "),s("code",[e._v("var [a, b, c] = [1, 2, 3];")])]),s("li",[e._v("字符串的扩展(模板字符串)  "),s("code",[e._v("var sum =")]),e._v("${a + b}"),s("code",[e._v(";")])]),s("li",[e._v("数组的扩展(转换数组类型)   "),s("code",[e._v("Array.from($('li'));")])]),s("li",[e._v("函数的扩展(扩展运算符)     "),s("code",[e._v("[1, 2].push(...[3, 4, 5]);")])]),s("li",[e._v("对象的扩展(同值相等算法)   "),s("code",[e._v("Object.is(NaN, NaN);")])]),s("li",[e._v("新增数据类型(Symbol)      "),s("code",[e._v("let uid = Symbol('uid');")])]),s("li",[e._v("新增数据结构(Map)        "),s("code",[e._v("let set = new Set([1, 2, 2, 3]);")])]),s("li",[e._v("for...of循环            "),s("code",[e._v("for(let val of arr){};")])]),s("li",[e._v("Promise对象            "),s("code",[e._v("var promise = new Promise(func);")])]),s("li",[e._v("Generator函数          "),s("code",[e._v("function* foo(x){yield x; return x*x;}")])]),s("li",[e._v("引入Class(类)          "),s("code",[e._v("class Foo {}")])]),s("li",[e._v("引入模块体系            "),s("code",[e._v("export default func;")])]),s("li",[e._v("引入async函数[ES7]")])]),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("async function asyncPrint(value, ms) {\n      await timeout(ms);\n      console.log(value)\n     }\n     \n")])])]),s("p",[s("strong",[e._v("Object.is() 与原来的比较操作符 ===、== 的区别？")])]),s("ul",[s("li",[e._v("== 相等运算符，比较时会自动进行数据类型转换")]),s("li",[e._v("=== 严格相等运算符，比较时不进行隐式类型转换")]),s("li",[e._v("Object.is 同值相等算法，在 === 基础上对 0 和 NaN 特别处理")])]),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("+0 === -0 //true\nNaN === NaN // false\n\nObject.is(+0, -0) // false\nObject.is(NaN, NaN) // true\n")])])]),s("p",[s("strong",[e._v("什么是 Babel ？")])]),s("ul",[s("li",[e._v("Babel 是一个 JS 编译器，自带一组 ES6 语法转化器，用于转化 JS 代码。\n这些转化器让开发者提前使用最新的 JS语法(ES6/ES7)，而不用等浏览器全部兼容。")]),s("li",[e._v("Babel 默认只转换新的 JS 句法(syntax)，而不转换新的API。")])])])}],!1,null,null,null);t.default=a.exports}}]);